---
layout: post
title:  "bash dialog example"
date:   2018-07-27 23:09:01 +0500
categories: jekyll update
---

Примеры кода для создания интерактивных интерфейсов в bash с помощью dialog.

### Примеры

* `--backtitle <TEXT>` - название в левом верхнем углу экрана
* `--checklist <TEXT> <WIND_HEIGHT> <LENGTH> <LIST_HEIGHT>` - выбор нескольких вариантов
* `--radiolist <TEXT> <WIND_HEIGHT> <LENGTH> <LIST_HEIGHT>` - выбор одного варианта
* `--inputbox <TEXT> <WIND_HEIGHT> <LENGTH> <LIST_HEIGHT>`
* `yesno <TEXT> <WIND_HEIGHT> <LENGTH>` - запрос на согласие, даёт код возврата


# Добавление дополнительной кнопки в меню

`dialog --extra-button --extra-label 123 --menu 0 0 0 0 0 0`
при нажатии на дополнительную кнопку код возврата будет равен `3`
Больше одной дополнительной кнопки не удалось мне сделать

# Захват вывода

Если надо ловить вывод, того что ввёл пользователь, то надо выкатывать error_out в файл(2>"MyFile")

Либо использовать такой вывод:
`value=$(dialog --menu 'lala' 10 42 1 1 1 3>&1 1>&2 2>&3 3>&-)`

То есть мы сначала, выводим пустой дескриптор `3` в `stdout`, затем `stdout` в `stderr`,
чтобы отобразился dialog, потом `stderr` в `3`, чтобы получить в переменную значение,
а по скольку порядок важен, поэтому в `stdin` получаем только переменну, а всё остальное
идёт на экран.

Требуется такие сложности, потому что вывод из dialog происходит в `stdout`, а то что ввёл пользователь в `stderr`.

Если вывод имеет код возврата, то ловим его
* Код 255 - означает, что клиент ввёл `Esc`. `CTRL-C` то же самое что нет в `yesno`


Из checklist вывод в файл происходит в ковычках, поэтому можно удялять их `sed -i 's/"//g'`

* Есть врапперы для питона в dialog. Вроде они удобнее, потому что есть нормальные списки и другие функции,
не надо придумывать велосипеды, чтобы избавляться от ковычек в выводе `checklist`, например.


# strict mode bash

Для применения `set -eu` можно либо выключать `set +e` strict mode на время запуска диалога, либо
использовать что-то на примере:
``` sh

set -eu
declare RC=""
lala=$(dialog --menu 20 20 1 2 3 4  5 6 3>&1 1>&2 2>&3 3>&- )  || RC=$?
if [ $RC = 0 ];
    echo lala
else
    echo nelala
fi

```

То есть мы ловим код возврата и обрабатываем все варианты
